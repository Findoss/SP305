  // private makeProxy(object: any) {
  //   // const self = this;
  //   return new Proxy(object, {
  //     get(target, newProps: string | number) {
  //       const value = target[newProps];
  //       return typeof value === 'function' ? value.bind(target) : value;
  //     },

  //     set(target, newProps, value: unknown) {
  //       target[newProps] = value;
  //       // self.eventBus.emit(EVENTS.FLOW_CDU, { ...target }, target);
  //       return true;
  //     },

  //     deleteProperty() {
  //       throw new Error('Нет доступа');
  //     },
  //   });
  // }


      // this.eventBus.on(
    //   Component.EVENTS.FLOW_CDM,
    //   this._componentDidMount.bind(this)
    // );
    // this.eventBus.on(Component.EVENTS.FLOW_CDU, (oldProps, newProps) =>
    //   this._componentDidUpdate(oldProps, newProps)
    // );
    // this.eventBus.on(Component.EVENTS.FLOW_RENDER, this._render.bind(this));
    // this.eventBus.on(
    //   Component.EVENTS.FLOW_ADD_EVENTS,
    //   this.addEvents.bind(this)
    // );


      // private _componentDidMount(): void {
  //   this.componentDidMount();
  //   this.eventBus.emit(Component.EVENTS.FLOW_RENDER);
  // }

  // public addEvents(): void {}

  // public componentDidMount(oldProps?: any): boolean {
  //   return true;
  // }

  // private _componentDidUpdate = (oldProps: any, newProps: any): void => {
  //   const response = this.componentDidUpdate(oldProps, newProps);
  //   if (!response) return;
  //   this.eventBus.emit(Component.EVENTS.FLOW_RENDER);
  // };

  // public componentDidUpdate(oldProps: any, newProps: any) {
  //   return true;
  // }

  // get element() {
  //   return this._element;
  // }

  // getContent() {
  //   return this.element;
  // }

  // getElement() {
  //   return document.querySelector(`[data-key=${this.id}]`);
  // }

  // private _render() {
  //   if (this._element) {
  //     this._element.innerHTML = this.render();
  //     setTimeout(() => {
  //       // del event
  //       this.eventBus.emit(Component.EVENTS.FLOW_ADD_EVENTS);
  //     }, 1);
  //   }
  // }

  // public render(): string {
  //   return '';
  // }

  // public mount(el: Element): void {
  //   el.innerHTML = '';
  //   el.appendChild(this._element);
  // }

  // show() {
  //   this.getContent().style.display = 'block';
  // }

  // hide() {
  //   this.getContent().style.display = 'none';
  // }

      this.childEventListeners = []; // каждый рендер DOM "обнуляется" и приходится заново вешать обработчики.

    const {context, template, eventListeners} = this.render(this.props);
    const compiledTemplate = Handlebars.compile(template);
    this.element.innerHTML = compiledTemplate(context || {});
    this.registerEventListeners(eventListeners);
    this.registerChildEventListenersInternal();
    this.eventBus.emit(VfcEvents.rendered);


    
  // beforeMount,
  // mount,
  // mounted,

    // MOUNT
  private mount(): void {
    this.eventBus.emit(EVENTS.beforeMount);
    // какие-то действия
    this.eventBus.emit(EVENTS.mounted);
  }

  public abstract beforeMountHandler(): void;
  public abstract mountedHandler(): void;


  
    this.eventBus.on(EVENTS.beforeMount, this.beforeMountHandler.bind(this));
    this.eventBus.on(EVENTS.update, this.mount.bind(this));
    this.eventBus.on(EVENTS.mounted, this.mountedHandler.bind(this));
