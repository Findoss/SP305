  
  
  title title--size-{{ size }} title--color-{{ color }}
  
  
  
  // private makeProxy(object: any) {
  //   // const self = this;
  //   return new Proxy(object, {
  //     get(target, newProps: string | number) {
  //       const value = target[newProps];
  //       return typeof value === 'function' ? value.bind(target) : value;
  //     },

  //     set(target, newProps, value: unknown) {
  //       target[newProps] = value;
  //       // self.eventBus.emit(EVENTS.FLOW_CDU, { ...target }, target);
  //       return true;
  //     },

  //     deleteProperty() {
  //       throw new Error('Нет доступа');
  //     },
  //   });
  // }


      // this.eventBus.on(
    //   Component.EVENTS.FLOW_CDM,
    //   this._componentDidMount.bind(this)
    // );
    // this.eventBus.on(Component.EVENTS.FLOW_CDU, (oldProps, newProps) =>
    //   this._componentDidUpdate(oldProps, newProps)
    // );
    // this.eventBus.on(Component.EVENTS.FLOW_RENDER, this._render.bind(this));
    // this.eventBus.on(
    //   Component.EVENTS.FLOW_ADD_EVENTS,
    //   this.addEvents.bind(this)
    // );


      // private _componentDidMount(): void {
  //   this.componentDidMount();
  //   this.eventBus.emit(Component.EVENTS.FLOW_RENDER);
  // }

  // public addEvents(): void {}

  // public componentDidMount(oldProps?: any): boolean {
  //   return true;
  // }

  // private _componentDidUpdate = (oldProps: any, newProps: any): void => {
  //   const response = this.componentDidUpdate(oldProps, newProps);
  //   if (!response) return;
  //   this.eventBus.emit(Component.EVENTS.FLOW_RENDER);
  // };

  // public componentDidUpdate(oldProps: any, newProps: any) {
  //   return true;
  // }

  // get element() {
  //   return this._element;
  // }

  // getContent() {
  //   return this.element;
  // }

  // getElement() {
  //   return document.querySelector(`[data-key=${this.id}]`);
  // }

  // private _render() {
  //   if (this._element) {
  //     this._element.innerHTML = this.render();
  //     setTimeout(() => {
  //       // del event
  //       this.eventBus.emit(Component.EVENTS.FLOW_ADD_EVENTS);
  //     }, 1);
  //   }
  // }

  // public render(): string {
  //   return '';
  // }

  // public mount(el: Element): void {
  //   el.innerHTML = '';
  //   el.appendChild(this._element);
  // }

  // show() {
  //   this.getContent().style.display = 'block';
  // }

  // hide() {
  //   this.getContent().style.display = 'none';
  // }

      this.childEventListeners = []; // каждый рендер DOM "обнуляется" и приходится заново вешать обработчики.

    const {context, template, eventListeners} = this.render(this.props);
    const compiledTemplate = Handlebars.compile(template);
    this.element.innerHTML = compiledTemplate(context || {});
    this.registerEventListeners(eventListeners);
    this.registerChildEventListenersInternal();
    this.eventBus.emit(VfcEvents.rendered);


    
  // beforeMount,
  // mount,
  // mounted,

    // MOUNT
  private mount(): void {
    this.eventBus.emit(EVENTS.beforeMount);
    // какие-то действия
    this.eventBus.emit(EVENTS.mounted);
  }

  public abstract beforeMountHandler(): void;
  public abstract mountedHandler(): void;


  
    this.eventBus.on(EVENTS.beforeMount, this.beforeMountHandler.bind(this));
    this.eventBus.on(EVENTS.update, this.mount.bind(this));
    this.eventBus.on(EVENTS.mounted, this.mountedHandler.bind(this));


// readonly template: string;
// readonly options: {
//   interpolate: RegExp;
// };


// {

// private lodashTemplate: Function;

// public toHTML(data: Object): string {
//   return this.lodashTemplate(data);
// }

//   public getTemplate(): Function {
//     return this.lodashTemplate;
//   }
// }


    // const { template, context } = this.render();
    // const compiledTemplate = new Template(template);
    // // console.log(this.props);
    // // console.log(this.state);
    // // console.log(propsDefault);
    // this.$element.innerHTML = compiledTemplate.toHTML({
    //   ...context,
    //   ...this.props,
    //   ...this.state,
    //   id: this.id,
    // });


  public beforeCreateHandler(): void {}
  public createdHandler(): void {
    let x = true;
    setInterval(() => {
      if (x) {
        this.setProps({
          errorText: 'ошибка не найдена',
          errorColor: 'green',
          img: './assets/images/backgrounds/404.svg',
        });
      } else {
        this.setProps({
          errorText: 'сломалось',
          errorColor: 'red',
          img: './assets/images/backgrounds/500.svg',
        });
      }
      x = !x;
    }, 2500);
  }
  public beforeUpdateHandler(): boolean {
    return true;
    // console.log('before', this.props);
  }
  public updatedHandler(): void {
    // console.log('after', this.props);
  }
  public beforeDestroyHandler(): void {}
  public destroyedHandler(): void {}


import { Component, EmptyState } from '../../classes/Component/index.js';
import { joinClasses } from '../../utils/joinClasses.js';

export type TextColors = 'red' | 'green';

export interface PropsTitle {
  text: string;
  level: number;
  size?: number;
  color?: TextColors;
}

export class Title extends Component<PropsTitle, EmptyState> {
  state: EmptyState;

  constructor(props: PropsTitle) {
    super(props);
    this.state = {};
  }

  public beforeCreateHandler() {}
  public createdHandler() {}
  public beforeUpdateHandler() {
    return true;
  }
  public updatedHandler() {
    // setTimeout(() => {
    //   this.setProps({
    //     color: 'red',
    //   });
    // }, 1000);
    // console.log(this.getProps());
  }
  public beforeDestroyHandler() {}
  public destroyedHandler() {}

  public styleClasses(): string {
    return joinClasses([
      'title',
      this.props?.size ? `title--size-${this.props.size}` : '',
      this.props?.color ? `title--color-${this.props.color}` : '',
    ]);
  }

  public render() {
    return {
      context: {
        text: '...',
        level: 1,
        styleClasses: this.styleClasses.bind(this),
      },
      template: `
        <h{{ level }}
          class="{{ styleClasses() }}"
        >
          {{ text }}
        </h{{ level }}>
      `,
    };
  }
}


    // if (element !== null) {
          // if (!this.$element) {
    // this.$element = element;
    // } else {
    //   const classList = element.getAttribute('class');

    //   if (classList) this.$element.setAttribute('class', classList);
    //   this.$element.innerHTML = element.innerHTML;
    // }
    // }
        //   //


  // public addHandlerValidation(
  //   event: TEventValidation = 'blur',
  //   callback?: TCallback,
  // ): void {
  //   if (this.inputs !== undefined) {
  //     Object.values(this.inputs).forEach((input) => {
  //       input.addEventListener(event, (e) => {
  //         if (callback === undefined) {
  //           this.submitHandler(e);
  //         } else {
  //           callback(e);
  //         }
  //       });
  //     });
  //   }
  // }


type TEventValidation = 'blur' | 'change';


  <!--  -->
      <!--  -->


// import template from '../../vendor/template.js';
// import { createSlot } from '../../utils/createSlot.js';


  // * old
  // const options = {
  //   escape: /{{-([\s\S]+?)}}/g,
  //   evaluate: /{{([\s\S]+?)}}/g,
  //   interpolate: /{{=([\s\S]+?)}}/g,
  //   imports: {
  //     SLOT: createSlot,
  //   },
  //   sourceURL,
  // };
  // return template(templateString, options);

  // * new

// export default (template: string, context: any): string => {
//   return compile(template)(context);
// };

// declare global {
//   const Handlebars;
// }

// export const { compile } = window.Handlebars;
// export default (template: string, context: any): string => {
//   return compile(template)(context);
// };

// var source = document.getElementById('entry-template')?.innerHTML;
// var x = window.Handlebars;

// console.log(x);

// import Handlebars from '../node_modules/handlebars/dist/handlebars.js';
// console.log(Handlebars);


import template from '../../vendor/template.js';
import { createSlot } from '../../utils/createSlot.js';

export function compileTemplate(
  templateString: string = '',
  sourceURL: string,
) {
  const options = {
    escape: /{{-([\s\S]+?)}}/g,
    evaluate: /{{([\s\S]+?)}}/g,
    interpolate: /{{=([\s\S]+?)}}/g,
    imports: {
      SLOT: createSlot,
    },
    sourceURL,
  };
  return template(templateString, options);
}

// declare global {
//   const Handlebars;
// }

// export const { compile } = window.Handlebars;
// export default (template: string, context: any): string => {
//   return compile(template)(context);
// };

// var source = document.getElementById('entry-template')?.innerHTML;
var x = window.Handlebars;
aaa
console.log(x);

// import Handlebars from '../node_modules/handlebars/dist/handlebars.js';
// console.log(Handlebars);

http {
  server {
    location / {
      root /client/source;
    }
  }
}

[build]
  publish = "client/source"
